<!DOCTYPE html>
<html>
    <head>
        <title>Tanks!</title>
        <style>
* {
    padding: 0;
    margin: 0;
    font-size: min(5vw, 5vh);
    font-family: monospace;
    
    touch-action: manipulation;
}

body {
    padding: 1em;
    background-color: #2c8520;
}

#loader {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    margin: 0 auto;
    position: relative;
    background-color: #42cf30;
    margin: 1em;
    vertical-align: bottom;
    position: absolute;
    bottom: 0;
    left: 0;
    max-height: calc(100vh - 2em);
    width: calc(100vw - 2em);
}

#loader * {
    height: 100%;
    width: 100%;
    margin: .5rem;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
    outline: 0;
    display: block;
}

#loader input {
    font-family: Courier;
}

#loader #nickname {
    width: 13rem;
}

#loader #playButton {
    padding-left: .5em;
    padding-right: .5em;
    width: auto;
    display: none;
}

#loader span {
    width: 100%;
    margin: 0;
    padding: 0;
    border: 0;
    height: 0;
}

#loader p:not(#status) {
    font-weight: normal;
    font-size: 4rem;
    font-family: Courier;
}

#content {
    overflow: hidden;
    position: fixed;
    top: 0;
    left: 0;
    display: none;
}
        </style>
    </head>
    <body>
        <div id="loader">
            <p>Tanks!</p>
            <input id="nickname" type="text" placeholder="nickname" autocomplete="off" spellcheck="false" maxlength="20">
            <p id="status">please enable javascript to connect</p>
            <span></span>
            <input id="playButton" type="button" value="Play">
        </div>
        <div id="content">
            <canvas id="canvas" width="100" height="100"></canvas>
        </div>
        <script>
//todo use const
var webSocket = null;
var loaderManager;
var networkManager;

var drawing = false;

var loader = document.getElementById("loader");
var playButton = document.getElementById("playButton");
var content = document.getElementById("content");

var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");

var lastFrame = 0;
var ping = 0;

var entities = {};
var player;
var playerId;
var keys = [];
var lastMouse;

var viewportX = 0;
var viewportY = 0;
var viewportWidth = 0; //maybe different from canvas.width in the future?
var viewportHeight = 0;
var updateViewport = false;

var tick = 0;
var lastSentTick = 0;
var serverTps = 0;

var tickRate;
var fontSize = 20;
var font = "pt Comic Sans MS";

function initialize() {
    loaderManager = new LoaderManager();
    networkManager = new NetworkManager();
    resize();
    
    connect();
}

window.onload = function(e) {
    canvas.addEventListener("mousemove", function(e) {
        lastMouse = e;
    });
    
    document.addEventListener("keydown", function(e) {
        if (!keys.includes(e.which)) {
            keys.push(e.which);
        }
    });
    
    document.addEventListener("keyup", function(e) {
        let index = keys[e.which];
        if (index !== -1) {
            keys.splice(index, 1);
        }
    });
    
    canvas.addEventListener("click", function(e) {
        if (typeof player !== "undefined") {
            let x = e.clientX - player.x - (player.width/2);
            let y = e.clientY - player.y - (player.height/2);
            let rotation;
            if (x < 0) {
                rotation = Math.atan(y/x) + Math.PI;
            } else {
                rotation = Math.atan(y/x) + Math.PI;
            }
            player.bullets.push(new Bullet(player.x + player.width/2 + (Math.cos(player.turret.rotation) * (player.turret.width + 10/2)) - 10/2, player.y + player.height/2 + (Math.sin(player.turret.rotation) * (player.turret.width + 10/2)) - 10/2, 10, 10, rotation, 0));
        }
    });
    
    playButton.addEventListener("click", function(e) {
        newClient();
        drawing = true;
        new Promise((resolve, reject) => {
            loader.style.display = "none";
            content.style.display = "block";
        });
    });
    window.addEventListener("resize", resize);
}

class LoaderManager { //todo unnecessary class?
    constructor() {
        this.dots = 0;
        this.running = false;
        this.status = document.getElementById("status");
    }

    update(go) {
        if (!this.running || go) {
            this.running = true;
            if (webSocket === null || webSocket.readyState !== WebSocket.OPEN) {
                this.status.style.display = "block";
                playButton.style.display = "none";
                if (this.dots > 3) {
                    this.dots = 0;
                }
            
                let dot = "";
                let begin = "";
                for (let i = 0; i < this.dots; i++) {
                    dot = dot + ".";
                    begin = begin + "&nbsp";
                }
                
                this.status.innerHTML = begin + "connecting" + dot;
              
                this.dots++;
                setTimeout(() => {
                    this.update(true);
                }, 250);
            } else {
                this.running = false;
            }
        }
    }
    
    onOpen() {
        this.status.innerHTML = "connected";
        this.status.style.display = "none";
        playButton.style.display = "block";
    }
}

class NetworkManager {
    constructor() {
        this.running = false;
        this.interval = null;
    }
    
    start(tps) {
        this.running = true;
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.interval = setInterval(() => {
            if (this.running && webSocket.readyState == WebSocket.OPEN) {
                let payload = {time:window.performance.now()};
                if (player) {
                    payload.player = player.serialize();
                }
                if (updateViewport) {
                    updateViewport = false;
                    payload.viewport = [viewportWidth, viewportHeight];
                }
                send(payload);
            } else {
                clearInterval(this.interval);
            }
        }, 1000/tps);
    }
    
    stop() {
        this.running = false;
    }
}

function connect() {
    console.log("Connecting to server...");
    new Promise((resolve, reject) => {
        loaderManager.update();
    });
    webSocket = new WebSocket("[[[SERVER_IP]]]");

    webSocket.onopen = function() {
        window.onbeforeunload = function(){
            webSocket.close();
        }

        console.log("Connected to server");
        loaderManager.onOpen();
    }

    webSocket.onclose = function() {
        console.log("Connection closed, attempting to reconnect...");
        document.getElementById("status").style.display = "block";
        document.getElementById("status").innerHTML = "disconnected, attempting to reconnect";
        playButton.style.display = "none";
        networkManager.stop();
        reconnect = setTimeout(connect, 1000);
    }

    webSocket.onmessage = function() {
        let payload;
        try {
            payload = JSON.parse(event.data);
        } catch (e) {
            console.log(event.data);
            console.log(e);
            return;
        }
        if (payload.information) {
            networkManager.start(parseInt(payload.information[0]));
        }
        if (payload.newPlayer) {
            playerId = payload.newPlayer[0];
        }
        if (payload.ping) {
            ping = payload.ping;
        }
        if (payload.tps) {
            serverTps = parseFloat(payload.tps);
        }
        if (payload.play) {
            tick = parseInt(payload.play.tick);
            for (let key in payload.play.grid) {
                let split = key.split(",", 2);
                let x = parseInt(split[0]);
                let y = parseInt(split[1]);
                if (payload.play.grid[key].entities) {
                    let ids = [];
                    for (let entityKey in payload.play.grid[key].entities) {
                        let rawEntity = payload.play.grid[key].entities[entityKey];
                        let entity;
                        if (rawEntity[0] === "player") {
                            entity = Player.deserialize(rawEntity);
                        } else {
                            entity = Entity.deserialize(rawEntity);
                        }
                        if (entity.id == playerId) {
                            if(typeof player === "undefined")
                            {
                                player = entity; //todo setProp
                            }
                        }
                        entities[entity.id] = entity;
                        ids.push(entity.id);
                    }
                    Object.keys(entities).forEach((key) => {
                        if (!ids.includes(key)) {
                            delete entities[key];
                        }
                    });
                }
            }
        }
    }
}

function send(payload) {
    if(webSocket.readyState === WebSocket.OPEN) {
        payload.time = Date.now();
        webSocket.send(JSON.stringify(payload));
        lastSentTick = tick;
    } else {
        return "Error: Not connected";
    }
}

function newClient() {
    send({newPlayer:[
            document.getElementById("nickname").value, //nickname
            canvas.width, //viewportWidth
            canvas.height //viewportHeight
    ]});
}

/* 
canvas 
*/

function draw(now) {
    if (drawing) {
        let dt = now-lastFrame;
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        
        //center viewport on player position
        if (player) {
            viewportX = player.x - viewportWidth / 2;
            viewportY = player.y - viewportHeight / 2;
        }
        ctx.translate(-viewportX, -viewportY);
        ctx.fillStyle = "gray";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = "green";
        Object.keys(entities).forEach((key) => {
            if(key === playerId)
            {
                player.draw(dt);
            }
            else
            {
                entities[key].draw(dt);
            }
        });
        
        ctx.restore();
        ctx.fillStyle = "white";
        ctx.font = fontSize + font;
        ctx.fillText(Math.round(1000/dt) + "fps", 10, 30);
        ctx.fillText(ping + "ms", 10, 60);
        ctx.fillText(tick + "tick", 10, 90);
        ctx.fillText(serverTps + "tps (server)", 10, 120);
        
        lastFrame = window.performance.now();
    } else {
        loader.style.display = "block";
        content.style.display = "none";
    }
    
    window.requestAnimationFrame(draw);
}

window.requestAnimationFrame(draw);

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    viewportWidth = canvas.width;
    viewportHeight = canvas.height;
    updateViewport = true;
    
    ctx.imageSmoothingEnabled = "false";
}

class Entity {
    constructor(id, x, y, speed, direction, rotation, width, height) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.direction = direction;
        this.rotation = rotation;
        this.width = width;
        this.height = height;
    }
    
    draw(dt) {
        this.x += this.speed * Math.acos(this.direction) * dt;
        this.y += this.speed * Math.asin(this.direction) * dt;

        ctx.save();
        ctx.rotate(this.rotation);
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.restore();
    }
    
    serialize() {
        return [this.id, this.x, this.y, this.speed, this.direction, this.rotation, this.width, this.height];
    }
    
    static deserialize(entity) {
        return new Entity(entity[0], entity[1], entity[2], entity[3], entity[4], entity[5], entity[6], entity[7]);
    }
}

class Player extends Entity {
    constructor(id, x, y, speed, direction, rotation, width, height, name, turret, bullets) {
        super(id, x, y, speed, direction, rotation, width, height);
        this.name = name;
        this.turret = turret;
        this.bullets = bullets;
    }
    
    draw(dt) {
        if (this.id === playerId) {
            this.speed = 1;
            if (keys.includes(87) && keys.includes(68)) {
                this.rotation = 7*Math.PI/4;
            } else if (keys.includes(68) && keys.includes(83)) {
                this.rotation = Math.PI/4;
            } else if (keys.includes(83) && keys.includes(65)) {
                this.rotation = 3*Math.PI/4;
            } else if (keys.includes(65) && keys.includes(87)) {
                this.rotation = 5*Math.PI/4;
            } else if (keys.includes(87)) {
                this.rotation = 3*Math.PI/2
            } else if (keys.includes(68)) {
                this.rotation = 0;
            } else if (keys.includes(83)) {
                this.rotation = Math.PI/2
            } else if (keys.includes(65)) {
                this.rotation = Math.PI;
            } else {
                this.speed = 0;
            }

            this.direction = this.rotation;

            if(typeof lastMouse !== "undefined") {
                let x = lastMouse.clientX + viewportX - this.x - (this.width/2);
                let y = lastMouse.clientY + viewportY - this.y - (this.height/2);
                if (x < 0) {
                    this.turret.rotation = Math.atan(y/x) + Math.PI - Math.PI / 2;
                } else {
                    this.turret.rotation = Math.atan(y/x) - Math.PI / 2;
                }
            }
        }

        this.x += Math.cos(this.direction) * this.speed * dt;
        this.y += Math.sin(this.direction) * this.speed * dt;
        
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        ctx.fillText(this.name, -ctx.measureText(this.name).width / 2, -fontSize - 5);

        ctx.save();
        ctx.fillStyle = "#1a7022";
        ctx.rotate(this.rotation);
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
        ctx.restore();
        
        ctx.save();
        ctx.fillStyle = "#00ff18";
        ctx.rotate(this.turret.rotation);
        ctx.fillRect(-this.turret.width / 2, 0, this.turret.width, this.turret.height);
        ctx.restore();
        
        ctx.restore();
        
        this.bullets.forEach((bullet) => {
            ctx.save();
            ctx.translate(bullet.x + bullet.width/2, bullet.y + bullet.height/2);
            ctx.rotate(0);
            ctx.fillText(this.name + "'s bullet", 20, 0);
            ctx.rotate(bullet.rot);
            ctx.fillRect(-bullet.width/2, -bullet.height/2, bullet.width, bullet.height);
            ctx.restore();
        });
    }
    
    serialize() {
        let bullets = [];
        this.bullets.forEach((bullet) => {
            bullets.push(bullet.serialize());
        });
        return ["player", super.serialize(), this.name, this.turret.serialize(), bullets];
    }
    
    static deserialize(entity) {
        let bullets = [];
        for (let bullet in entity[4]) {
            bullets.push(Bullet.deserialize(bullet));
        }
        let ent = Entity.deserialize(entity[1]);
        return new Player(ent.id, ent.x, ent.y, ent.speed, ent.direction, ent.rotation, ent.width, ent.height, entity[2], Turret.deserialize(entity[3]), bullets);
    }
}

class Bullet extends Entity {
    constructor(id, x, y, speed, direction, rotation, width, height, owner, hits) {
        super(id, x, y, speed, direction, rotation, width, height, owner);
        this.hits = hits;
    }
    
    serialize() {
        let array = super.serialize();
        array.push(this.hits);
        return array;
    }
    
    static deserialize(entity) {
        return new Bullet(entity[0], entity[1], entity[2], entity[3], entity[4], entity[5], entity[6], entity[7], entity[8]);
    }
}

class Turret {
    constructor(rotation, width, height) {
        this.rotation = rotation;
        this.width = width;
        this.height = height;
    }
    
    serialize() {
        return [this.rotation, this.width, this.height];
    }
    
    static deserialize(turret) {
        return new Turret(turret[0], turret[1], turret[2]);
    }
}

initialize();
        </script>
    </body>
</html>